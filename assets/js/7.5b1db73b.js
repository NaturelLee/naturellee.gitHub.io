(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{194:function(t,s,a){t.exports=a.p+"assets/img/spaces.417e14b3.png"},195:function(t,s,a){t.exports=a.p+"assets/img/segments.a8b51772.png"},240:function(t,s,a){"use strict";a.r(s);var e=a(0),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"操作系统相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作系统相关"}},[t._v("#")]),t._v(" 操作系统相关")]),t._v(" "),e("h2",{attrs:{id:"虚拟地址空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟地址空间"}},[t._v("#")]),t._v(" 虚拟地址空间")]),t._v(" "),e("p",[t._v("在 32 位机器下，虚拟地址空间大小为 4G。这些虚拟地址通过页表 (Page Table) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (MMU) 硬件引用。"),e("strong",[t._v("每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。")])]),t._v(" "),e("p",[t._v("Linux 将这 4G 的空间分为两个部分：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(194),alt:""}})]),t._v(" "),e("ol",[e("li",[t._v("Kernel space 内核空间。")]),t._v(" "),e("li",[t._v("User Mode Space 用户空间。")])]),t._v(" "),e("p",[e("strong",[t._v("每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。")])]),t._v(" "),e("p",[e("strong",[t._v("换句话说就是， 最高 1G 的内核空间是被所有进程共享的！")])]),t._v(" "),e("p",[t._v("而上面进程虚拟地址空间中的栈区，正指的是我们所说的"),e("strong",[t._v("进程栈")]),t._v("。进程栈的实时大小并不固定，它也有最大限制 RLIMIT_STACK (一般为 8M)。")]),t._v(" "),e("p",[t._v("一个进程至少有一个线程，主线程有自己的栈，64 位 Linux rust 程序主线程栈是 8M。其他程序线程默认是 2M。")]),t._v(" "),e("h3",{attrs:{id:"进程、线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程、线程"}},[t._v("#")]),t._v(" 进程、线程")]),t._v(" "),e("ol",[e("li",[t._v("从 Linux 内核的角度来说，其实它并没有线程的概念。线程仅仅被视为一个与"),e("strong",[t._v("其他进程共享某些资源")]),t._v("的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。")]),t._v(" "),e("li",[t._v("线程的内存描述符 将直接指向 父进程的内存描述符。")]),t._v(" "),e("li",[t._v("线程一旦创建就无法在修改其栈大小了，一旦用尽就没了，由于"),e("strong",[t._v("线程栈")]),t._v("是从进程的地址空间中 map 出来的一块内存区域，"),e("strong",[t._v("原则上是线程私有的")]),t._v("。")]),t._v(" "),e("li",[t._v("由于进程间是隔离的,各自拥有自己的内存内存资源。")])]),t._v(" "),e("h3",{attrs:{id:"进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),e("ol",[e("li",[t._v("进程是系统分配资源的最小单位")]),t._v(" "),e("li",[t._v("线程是 CPU 调度的最小单位")]),t._v(" "),e("li",[t._v("由于默认进程内只有一个线程,所以多核 CPU 处理多进程就像是一个进程一个核心")])]),t._v(" "),e("h3",{attrs:{id:"线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),e("ol",[e("li",[t._v("线程属于进程")]),t._v(" "),e("li",[t._v("线程共享进程的内存地址空间")]),t._v(" "),e("li",[t._v("线程几乎不占有系统资源")])]),t._v(" "),e("h2",{attrs:{id:"memory-segment-内存段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memory-segment-内存段"}},[t._v("#")]),t._v(" Memory segment: 内存段")]),t._v(" "),e("p",[e("img",{attrs:{src:a(195),alt:"",title:"segments"}})]),t._v(" "),e("h3",{attrs:{id:"text-segment-代码段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#text-segment-代码段"}},[t._v("#")]),t._v(" text segment: 代码段")]),t._v(" "),e("p",[t._v("用于"),e("strong",[t._v("存放程序代码")]),t._v("的区域，编译时确定，只读。更进一步讲是存放处理器的机器指令")]),t._v(" "),e("h3",{attrs:{id:"data-segment-数据段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#data-segment-数据段"}},[t._v("#")]),t._v(" data segment: 数据段")]),t._v(" "),e("p",[t._v("用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的"),e("strong",[t._v("静态存储区")]),t._v("，"),e("strong",[t._v("赋了初值的")]),t._v("全局变量、常量和静态变量都存放在这个域。")]),t._v(" "),e("h3",{attrs:{id:"bss-segment"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bss-segment"}},[t._v("#")]),t._v(" bss: segment")]),t._v(" "),e("p",[t._v("即: block started by symbol segment")]),t._v(" "),e("p",[t._v("通常是指用来存放程序中"),e("strong",[t._v("未初始化的全局变量")]),t._v("，初始化时 bss 部分将会清零。")]),t._v(" "),e("h3",{attrs:{id:"heap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#heap"}},[t._v("#")]),t._v(" heap")]),t._v(" "),e("p",[t._v("存放进程运行中动态 分配的内存段，大小不固定。")]),t._v(" "),e("p",[t._v("同一进程中的所有线程共享这一块内存。")]),t._v(" "),e("h3",{attrs:{id:"stack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stack"}},[t._v("#")]),t._v(" stack")])])}),[],!1,null,null,null);s.default=_.exports}}]);