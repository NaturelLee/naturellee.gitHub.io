(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{194:function(v,_,t){v.exports=t.p+"assets/img/complexity.31f735f2.png"},235:function(v,_,t){"use strict";t.r(_);var a=t(0),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),a("h2",{attrs:{id:"复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[v._v("#")]),v._v(" 复杂度分析")]),v._v(" "),a("h3",{attrs:{id:"一、什么是复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是复杂度分析"}},[v._v("#")]),v._v(" 一、什么是复杂度分析？")]),v._v(" "),a("ol",[a("li",[v._v("数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。")]),v._v(" "),a("li",[v._v("因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。")]),v._v(" "),a("li",[v._v("分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。")]),v._v(" "),a("li",[v._v("复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。")])]),v._v(" "),a("h4",{attrs:{id:"二、为什么要进行复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、为什么要进行复杂度分析"}},[v._v("#")]),v._v(" 二、为什么要进行复杂度分析？")]),v._v(" "),a("ol",[a("li",[v._v("和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。")]),v._v(" "),a("li",[v._v("掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。")])]),v._v(" "),a("h4",{attrs:{id:"三、如何进行复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、如何进行复杂度分析"}},[v._v("#")]),v._v(" 三、如何进行复杂度分析？")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("大O表示法")]),v._v(" "),a("ol",[a("li",[v._v("来源\n算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。")]),v._v(" "),a("li",[v._v("特点\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。")])])]),v._v(" "),a("li",[a("p",[v._v("复杂度分析法则")]),v._v(" "),a("ol",[a("li",[v._v("单段代码看高频：比如循环。")]),v._v(" "),a("li",[v._v("多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。")]),v._v(" "),a("li",[v._v("嵌套代码求乘积：比如递归、多重循环等")]),v._v(" "),a("li",[v._v("多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。")])])])]),v._v(" "),a("h4",{attrs:{id:"四、常用的复杂度级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、常用的复杂度级别"}},[v._v("#")]),v._v(" 四、常用的复杂度级别？")]),v._v(" "),a("ol",[a("li",[v._v("多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，\nO(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）")]),v._v(" "),a("li",[v._v("非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，\nO(2^n)（指数阶）、O(n!)（阶乘阶）")])]),v._v(" "),a("h3",{attrs:{id:"时间复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析"}},[v._v("#")]),v._v(" 时间复杂度分析")]),v._v(" "),a("p",[v._v("全称是渐进时间复杂度（asymptotic time complexity），表示算法的"),a("strong",[v._v("执行时间")]),v._v("与数据规模之间的增长关系。")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("1. 只关注循环执行次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 --- 嵌套循环\n")])])]),a("p",[a("img",{attrs:{src:t(194),alt:"complexity"}})]),v._v(" "),a("ol",[a("li",[v._v("常量阶O(1)： 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。")]),v._v(" "),a("li",[v._v("对数阶O(log n)：")]),v._v(" "),a("li",[v._v("线性阶O(n)：")]),v._v(" "),a("li",[v._v("O(m + n), O(m * n)：")]),v._v(" "),a("li",[v._v("线性对数阶O(n log n)：")]),v._v(" "),a("li",[v._v("平方阶O(n^2)、立方阶O(n^3)、...k次方阶O(n^k)：")]),v._v(" "),a("li",[v._v("指数阶O(2^n)：")]),v._v(" "),a("li",[v._v("阶乘阶O(n!)：")])]),v._v(" "),a("h3",{attrs:{id:"空间复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度分析"}},[v._v("#")]),v._v(" 空间复杂度分析")]),v._v(" "),a("p",[v._v("全称就是渐进空间复杂度（asymptotic space complexity），表示算法的"),a("strong",[v._v("存储空间")]),v._v("与数据规模之间的增长关系。")]),v._v(" "),a("h3",{attrs:{id:"四个方面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四个方面"}},[v._v("#")]),v._v(" 四个方面：")]),v._v(" "),a("ol",[a("li",[v._v("最好情况时间复杂度（best case time complexity）")]),v._v(" "),a("li",[v._v("最坏情况时间复杂度（worst case time complexity）")]),v._v(" "),a("li",[v._v("平均情况时间复杂度（average case time complexity）：加权平均")]),v._v(" "),a("li",[v._v("均摊时间复杂度（amortized time complexity）, 摊还分析")])]),v._v(" "),a("h2",{attrs:{id:"_20个最常用、最基础的数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20个最常用、最基础的数据结构和算法"}},[v._v("#")]),v._v(" 20个最常用、最基础的数据结构和算法")]),v._v(" "),a("ol",[a("li",[v._v("10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；")]),v._v(" "),a("li",[v._v("10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。")])]),v._v(" "),a("h2",{attrs:{id:"学习技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#学习技巧"}},[v._v("#")]),v._v(" 学习技巧")]),v._v(" "),a("p",[v._v("要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”。")]),v._v(" "),a("ol",[a("li",[v._v("边学边练，适度刷题")])]),v._v(" "),a("h2",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),a("ol",[a("li",[v._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")]),v._v(" "),a("li",[v._v("数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。")])]),v._v(" "),a("h3",{attrs:{id:"低效的-插入-和-删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#低效的-插入-和-删除"}},[v._v("#")]),v._v(" 低效的“插入”和“删除”")]),v._v(" "),a("ol",[a("li",[v._v("插入、删除操作比较低效，平均情况时间复杂度为 O(n)。")])]),v._v(" "),a("h2",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),a("h3",{attrs:{id:"缓存淘汰策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存淘汰策略"}},[v._v("#")]),v._v(" 缓存淘汰策略")]),v._v(" "),a("ol",[a("li",[v._v("先进先出策略 FIFO（First In，First Out）")]),v._v(" "),a("li",[v._v("最少使用策略 LFU（Least Frequently Used）")]),v._v(" "),a("li",[v._v("最近最少使用策略 LRU（Least Recently Used）。")])]),v._v(" "),a("h3",{attrs:{id:"表结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表结构"}},[v._v("#")]),v._v(" 表结构")]),v._v(" "),a("ol",[a("li",[v._v("单链表、双向链表和循环链表。")]),v._v(" "),a("li",[v._v("单链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。")]),v._v(" "),a("li",[v._v("单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点")]),v._v(" "),a("li",[v._v("双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。")]),v._v(" "),a("li",[v._v("写链表代码技巧\n"),a("ol",[a("li",[v._v("理解指针或引用的含义：指针中存储了这个变量的内存地址")]),v._v(" "),a("li",[v._v("警惕指针丢失和内存泄漏")]),v._v(" "),a("li",[v._v("利用哨兵简化实现难度")]),v._v(" "),a("li",[v._v("重点留意边界条件处理")]),v._v(" "),a("li",[v._v("举例画图，辅助思考")]),v._v(" "),a("li",[v._v("多写多练，没有捷径")])])]),v._v(" "),a("li",[v._v("5 个常见的链表操作\n"),a("ol",[a("li",[v._v("单链表反转")]),v._v(" "),a("li",[v._v("链表中环的检测")]),v._v(" "),a("li",[v._v("两个有序的链表合并")]),v._v(" "),a("li",[v._v("删除链表倒数第 n 个结点")]),v._v(" "),a("li",[v._v("求链表的中间结点")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);