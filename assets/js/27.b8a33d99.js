(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{252:function(e,t,a){"use strict";a.r(t);var s=a(0),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"rust-std-docs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rust-std-docs"}},[e._v("#")]),e._v(" Rust Std Docs")]),e._v(" "),t("h2",{attrs:{id:"cell"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cell"}},[e._v("#")]),e._v(" Cell")]),e._v(" "),t("h2",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[e._v("#")]),e._v(" String")]),e._v(" "),t("h3",{attrs:{id:"str"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#str"}},[e._v("#")]),e._v(" &str")]),e._v(" "),t("div",{staticClass:"language-rust line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-rust"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// string literal")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" s2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("str")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Hello, world!"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("ol",[t("li",[e._v("&str is stored directly in the compiled binary.")]),e._v(" "),t("li",[e._v("Stored in Text/Code segment.")]),e._v(" "),t("li",[e._v("&str has a static lifetime. They are never deallocated.")])]),e._v(" "),t("h2",{attrs:{id:"misconceptions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#misconceptions"}},[e._v("#")]),e._v(" Misconceptions")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Phrase")]),e._v(" "),t("th",[e._v("Shorthand for")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[t("code",[e._v("T")])]),e._v(" "),t("td",[e._v("1) a set containing all possible types "),t("em",[e._v("or")]),t("br"),e._v("2) some type within that set")])]),e._v(" "),t("tr",[t("td",[e._v("owned type")]),e._v(" "),t("td",[e._v("some non-reference type, e.g. "),t("code",[e._v("i32")]),e._v(", "),t("code",[e._v("String")]),e._v(", "),t("code",[e._v("Vec")]),e._v(", etc")])]),e._v(" "),t("tr",[t("td",[e._v("1) borrowed type "),t("em",[e._v("or")]),t("br"),e._v("2) ref type")]),e._v(" "),t("td",[e._v("some reference type regardless of mutability, e.g. "),t("code",[e._v("&i32")]),e._v(", "),t("code",[e._v("&mut i32")]),e._v(", etc")])]),e._v(" "),t("tr",[t("td",[e._v("1) mut ref "),t("em",[e._v("or")]),t("br"),e._v("2) exclusive ref")]),e._v(" "),t("td",[e._v("exclusive mutable reference, i.e. "),t("code",[e._v("&mut T")])])]),e._v(" "),t("tr",[t("td",[e._v("1) immut ref "),t("em",[e._v("or")]),t("br"),e._v("2) shared ref")]),e._v(" "),t("td",[e._v("shared immutable reference, i.e. "),t("code",[e._v("&T")])])])])]),e._v(" "),t("h3",{attrs:{id:"t-t-mut-t"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#t-t-mut-t"}},[e._v("#")]),e._v(" T, &T, &mut T")]),e._v(" "),t("ol",[t("li",[e._v("T is a superset of both &T and &mut T")]),e._v(" "),t("li",[e._v("&T and &mut T are disjoint sets")])]),e._v(" "),t("h3",{attrs:{id:"t-static"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#t-static"}},[e._v("#")]),e._v(" T: 'static")]),e._v(" "),t("ol",[t("li",[e._v("T: 'static should be read as \"T is bounded by a 'static lifetime\"")]),e._v(" "),t("li",[e._v("if T: 'static then T can be a borrowed type with a 'static lifetime or an owned type")]),e._v(" "),t("li",[e._v("since T: 'static includes owned types that means T\n"),t("ol",[t("li",[e._v("can be dynamically allocated at run-time")]),e._v(" "),t("li",[e._v("does not have to be valid for the entire program")]),e._v(" "),t("li",[e._v("can be safely and freely mutated")]),e._v(" "),t("li",[e._v("can be dynamically dropped at run-time")]),e._v(" "),t("li",[e._v("can have lifetimes of different durations")])])])]),e._v(" "),t("h3",{attrs:{id:"a-t-and-t-a"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-t-and-t-a"}},[e._v("#")]),e._v(" &‘a T and T: 'a")]),e._v(" "),t("ol",[t("li",[e._v("T: 'a is more general and more flexible than &'a T")]),e._v(" "),t("li",[e._v("T: 'a accepts owned types, owned types which contain references, and references")]),e._v(" "),t("li",[e._v("&'a T only accepts references")]),e._v(" "),t("li",[e._v("if T: 'static then T: 'a since 'static >= 'a for all 'a")])]),e._v(" "),t("h3",{attrs:{id:"lifetime"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lifetime"}},[e._v("#")]),e._v(" lifetime")]),e._v(" "),t("ol",[t("li",[e._v("almost all Rust code is generic code and there's elided lifetime annotations everywhere")]),e._v(" "),t("li",[e._v("Rust's lifetime elision rules for functions are not always right for every situation")]),e._v(" "),t("li",[e._v("Rust does not know more about the semantics of your program than you do")]),e._v(" "),t("li",[e._v("give your lifetime annotations descriptive names")]),e._v(" "),t("li",[e._v("try to be mindful of where you place explicit lifetime annotations and why")]),e._v(" "),t("li",[e._v("all trait objects have some inferred default lifetime bounds")]),e._v(" "),t("li",[e._v("Rust's lifetime elision rules for trait objects are not always right for every situation")]),e._v(" "),t("li",[e._v("Rust does not know more about the semantics of your program than you do")]),e._v(" "),t("li",[e._v("Rust compiler error messages suggest fixes which will make your program compile which is not that same as fixes which will 1. make you program compile and best suit the requirements of your program")]),e._v(" "),t("li",[e._v("lifetimes are statically verified at compile-time")]),e._v(" "),t("li",[e._v("lifetimes cannot grow or shrink or change in any way at run-time")]),e._v(" "),t("li",[e._v("Rust borrow checker will always choose the shortest possible lifetime for a variable assuming all code paths can be taken")]),e._v(" "),t("li",[e._v("try not to re-borrow mut refs as shared refs, or you're gonna have a bad time")]),e._v(" "),t("li",[e._v("re-borrowing a mut ref doesn't end its lifetime, even if the ref is dropped")])]),e._v(" "),t("h3",{attrs:{id:"lifetime-outlives"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lifetime-outlives"}},[e._v("#")]),e._v(" lifetime: outlives")]),e._v(" "),t("p",[t("code",[e._v("'long: 'short")]),e._v(" is read \"'long outlives 'short\".")]),e._v(" "),t("p",[t("code",[e._v("'a:'b")]),e._v(" means that the lifetime 'a outlives the lifetime 'b")]),e._v(" "),t("h3",{attrs:{id:"closure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#closure"}},[e._v("#")]),e._v(" Closure")]),e._v(" "),t("p",[t("strong",[e._v("一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们")]),e._v("。"),t("code",[e._v("move")]),e._v(" 本身强调的就是后者，闭包如何捕获变量")])])}),[],!1,null,null,null);t.default=r.exports}}]);