(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{211:function(t,n,e){"use strict";e.r(n);var s=e(0),a=Object(s.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"restful"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#restful"}},[this._v("#")]),this._v(" Restful")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[this._v("1. 资源是REST系统的核心概念。 所有的设计都是以资源为中心\n2. 围绕资源进行 添加，获取，修改，删除，以及对符合特定条件的资源进行列表操作 。针对资源设计接口\n3. 获取用户信息 GET /v1/users/{username} 参数放在路径中\n4. 获取应用管理员列表 GET /v1/admins?start={start}&count={count} ？后拼接参数的方式：这种方式一般作为过滤资源\n5. 选择请求接口的方式： get delete\nPUT 在服务器更新资源（客户端提供改变后的完整资源）。\nPOST 在服务器新建一个资源\n6. 资源与URI\n\ta. URI设计技巧\n\t\ti. 使用_或-来让URI可读性更好\n\t\tii. 使用/来表示资源的层级关系\n\t\tiii. 使用?用来过滤资源\n\t\tiv. ,或;可以用来表示同级资源的关系\n7.  统一资源接口\n8. 状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。\n客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。\n服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。\n这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。\n9. Rest架构的主要原则    \n\ta.  网络上的所有事物都被抽象为资源    \n\tb. 每个资源都有一个唯一的资源标识符    \n\tc.  同一个资源具有多种表现形式(xml,json等)    \n\td. 对资源的各种操作不会改变资源标识符    \n\te. 所有的操作都是无状态的    \n\tf.  符合REST原则的架构方式即可称为RESTful\n10. REST： URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。\nREST -- REpresentational State Transfer\n全称是 Resource Representational State Transfer：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：\nResource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；\nRepresentational：某种表现形式，比如用JSON，XML，JPEG等；\nState Transfer：状态变化。通过HTTP动词实现。\n11. 看Url就知道要什么\n看http method就知道干什么\n看http status code就知道结果如何\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);