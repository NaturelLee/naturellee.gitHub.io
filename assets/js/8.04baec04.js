(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{194:function(v,_,t){v.exports=t.p+"assets/img/complexity.31f735f2.png"},235:function(v,_,t){"use strict";t.r(_);var a=t(0),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),a("h2",{attrs:{id:"复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[v._v("#")]),v._v(" 复杂度分析")]),v._v(" "),a("h3",{attrs:{id:"一、什么是复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是复杂度分析"}},[v._v("#")]),v._v(" 一、什么是复杂度分析？")]),v._v(" "),a("ol",[a("li",[v._v("数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。")]),v._v(" "),a("li",[v._v("因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。")]),v._v(" "),a("li",[v._v("分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。")]),v._v(" "),a("li",[v._v("复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。")])]),v._v(" "),a("h4",{attrs:{id:"二、为什么要进行复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、为什么要进行复杂度分析"}},[v._v("#")]),v._v(" 二、为什么要进行复杂度分析？")]),v._v(" "),a("ol",[a("li",[v._v("和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。")]),v._v(" "),a("li",[v._v("掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。")])]),v._v(" "),a("h4",{attrs:{id:"三、如何进行复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、如何进行复杂度分析"}},[v._v("#")]),v._v(" 三、如何进行复杂度分析？")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("大O表示法")]),v._v(" "),a("ol",[a("li",[v._v("来源\n算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。")]),v._v(" "),a("li",[v._v("特点\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。")])])]),v._v(" "),a("li",[a("p",[v._v("复杂度分析法则")]),v._v(" "),a("ol",[a("li",[v._v("单段代码看高频：比如循环。")]),v._v(" "),a("li",[v._v("多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。")]),v._v(" "),a("li",[v._v("嵌套代码求乘积：比如递归、多重循环等")]),v._v(" "),a("li",[v._v("多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。")])])])]),v._v(" "),a("h4",{attrs:{id:"四、常用的复杂度级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、常用的复杂度级别"}},[v._v("#")]),v._v(" 四、常用的复杂度级别？")]),v._v(" "),a("ol",[a("li",[v._v("多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，\nO(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）")]),v._v(" "),a("li",[v._v("非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，\nO(2^n)（指数阶）、O(n!)（阶乘阶）")])]),v._v(" "),a("h3",{attrs:{id:"时间复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析"}},[v._v("#")]),v._v(" 时间复杂度分析")]),v._v(" "),a("p",[v._v("全称是渐进时间复杂度（asymptotic time complexity），表示算法的"),a("strong",[v._v("执行时间")]),v._v("与数据规模之间的增长关系。")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("1. 只关注循环执行次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 --- 嵌套循环\n")])])]),a("p",[a("img",{attrs:{src:t(194),alt:"complexity"}})]),v._v(" "),a("ol",[a("li",[v._v("常量阶O(1)： 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。")]),v._v(" "),a("li",[v._v("对数阶O(log n)：")]),v._v(" "),a("li",[v._v("线性阶O(n)：")]),v._v(" "),a("li",[v._v("O(m + n), O(m * n)：")]),v._v(" "),a("li",[v._v("线性对数阶O(n log n)：")]),v._v(" "),a("li",[v._v("平方阶O(n^2)、立方阶O(n^3)、...k次方阶O(n^k)：")]),v._v(" "),a("li",[v._v("指数阶O(2^n)：")]),v._v(" "),a("li",[v._v("阶乘阶O(n!)：")])]),v._v(" "),a("h3",{attrs:{id:"空间复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度分析"}},[v._v("#")]),v._v(" 空间复杂度分析")]),v._v(" "),a("p",[v._v("全称就是渐进空间复杂度（asymptotic space complexity），表示算法的"),a("strong",[v._v("存储空间")]),v._v("与数据规模之间的增长关系。")]),v._v(" "),a("h3",{attrs:{id:"四个方面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四个方面"}},[v._v("#")]),v._v(" 四个方面：")]),v._v(" "),a("ol",[a("li",[v._v("最好情况时间复杂度（best case time complexity）")]),v._v(" "),a("li",[v._v("最坏情况时间复杂度（worst case time complexity）")]),v._v(" "),a("li",[v._v("平均情况时间复杂度（average case time complexity）：加权平均")]),v._v(" "),a("li",[v._v("均摊时间复杂度（amortized time complexity）, 摊还分析")])]),v._v(" "),a("h2",{attrs:{id:"_20个最常用、最基础的数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20个最常用、最基础的数据结构和算法"}},[v._v("#")]),v._v(" 20个最常用、最基础的数据结构和算法")]),v._v(" "),a("ol",[a("li",[v._v("10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；")]),v._v(" "),a("li",[v._v("10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。")])]),v._v(" "),a("h2",{attrs:{id:"学习技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#学习技巧"}},[v._v("#")]),v._v(" 学习技巧")]),v._v(" "),a("p",[v._v("要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”。")]),v._v(" "),a("ol",[a("li",[v._v("边学边练，适度刷题")])]),v._v(" "),a("h2",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),a("ol",[a("li",[v._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")]),v._v(" "),a("li",[v._v("数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。")])]),v._v(" "),a("h3",{attrs:{id:"低效的-插入-和-删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#低效的-插入-和-删除"}},[v._v("#")]),v._v(" 低效的“插入”和“删除”")]),v._v(" "),a("ol",[a("li",[v._v("插入、删除操作比较低效，平均情况时间复杂度为 O(n)。")])]),v._v(" "),a("h2",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),a("h3",{attrs:{id:"缓存淘汰策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存淘汰策略"}},[v._v("#")]),v._v(" 缓存淘汰策略")]),v._v(" "),a("ol",[a("li",[v._v("先进先出策略 FIFO（First In，First Out）")]),v._v(" "),a("li",[v._v("最少使用策略 LFU（Least Frequently Used）")]),v._v(" "),a("li",[v._v("最近最少使用策略 LRU（Least Recently Used）。")])]),v._v(" "),a("h3",{attrs:{id:"表结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表结构"}},[v._v("#")]),v._v(" 表结构")]),v._v(" "),a("ol",[a("li",[v._v("单链表、双向链表和循环链表。")]),v._v(" "),a("li",[v._v("单链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。")]),v._v(" "),a("li",[v._v("单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点")]),v._v(" "),a("li",[v._v("双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。")]),v._v(" "),a("li",[v._v("写链表代码技巧\n"),a("ol",[a("li",[v._v("理解指针或引用的含义：指针中存储了这个变量的内存地址")]),v._v(" "),a("li",[v._v("警惕指针丢失和内存泄漏")]),v._v(" "),a("li",[v._v("利用哨兵简化实现难度")]),v._v(" "),a("li",[v._v("重点留意边界条件处理")]),v._v(" "),a("li",[v._v("举例画图，辅助思考")]),v._v(" "),a("li",[v._v("多写多练，没有捷径")])])]),v._v(" "),a("li",[v._v("5 个常见的链表操作\n"),a("ol",[a("li",[v._v("单链表反转")]),v._v(" "),a("li",[v._v("链表中环的检测")]),v._v(" "),a("li",[v._v("两个有序的链表合并")]),v._v(" "),a("li",[v._v("删除链表倒数第 n 个结点")]),v._v(" "),a("li",[v._v("求链表的中间结点")])])])]),v._v(" "),a("h2",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),a("h3",{attrs:{id:"what"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what"}},[v._v("#")]),v._v(" What")]),v._v(" "),a("ol",[a("li",[v._v("栈是一种“操作受限”的线性表")]),v._v(" "),a("li",[v._v("特定的数据结构是对特定场景的抽象")])]),v._v(" "),a("h3",{attrs:{id:"how"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how"}},[v._v("#")]),v._v(" How")]),v._v(" "),a("ol",[a("li",[v._v("用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。")])]),v._v(" "),a("h3",{attrs:{id:"when"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#when"}},[v._v("#")]),v._v(" When")]),v._v(" "),a("ol",[a("li",[v._v("函数调用栈")]),v._v(" "),a("li",[v._v("表达式求值")]),v._v(" "),a("li",[v._v("括号匹配")])]),v._v(" "),a("h2",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[v._v("#")]),v._v(" 队列")]),v._v(" "),a("ol",[a("li",[v._v("队列是一种先进先出的数据结构：操作：入队(enqueue)和出队(dequeue)")]),v._v(" "),a("li",[v._v("也是一种操作受限的线性表数据结构。")]),v._v(" "),a("li",[v._v("用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。")]),v._v(" "),a("li",[v._v("队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。")]),v._v(" "),a("li",[v._v("循环队列： 最关键的是，确定好队空和队满的判定条件。")]),v._v(" "),a("li",[v._v("阻塞队列和并发队列")])]),v._v(" "),a("h2",{attrs:{id:"递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[v._v("#")]),v._v(" 递归")]),v._v(" "),a("ol",[a("li",[v._v("递归是一种应用非常广泛的算法（或者编程技巧")]),v._v(" "),a("li",[v._v("递归需要满足的三个条件\n"),a("ol",[a("li",[v._v("一个问题的解可以分解为几个子问题的解")]),v._v(" "),a("li",[v._v("这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样")]),v._v(" "),a("li",[v._v("存在递归终止条件")])])]),v._v(" "),a("li",[v._v("如何编写递归代码？写递归代码最关键的是写出递推公式，找到终止条件")]),v._v(" "),a("li",[v._v("递归代码要警惕堆栈溢出")]),v._v(" "),a("li",[v._v("递归代码要警惕重复计算")])]),v._v(" "),a("h2",{attrs:{id:"排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[v._v("#")]),v._v(" 排序")]),v._v(" "),a("h3",{attrs:{id:"分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[v._v("#")]),v._v(" 分类")]),v._v(" "),a("ol",[a("li",[v._v("冒泡、插入、选择")]),v._v(" "),a("li",[v._v("快排、归并")]),v._v(" "),a("li",[v._v("桶、计数、基数")])]),v._v(" "),a("h3",{attrs:{id:"如何分析一个排序算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何分析一个排序算法"}},[v._v("#")]),v._v(" 如何分析一个排序算法")]),v._v(" "),a("h4",{attrs:{id:"排序算法的执行效率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的执行效率"}},[v._v("#")]),v._v(" 排序算法的执行效率")]),v._v(" "),a("ol",[a("li",[v._v("最好情况、最坏情况、平均情况时间复杂度")]),v._v(" "),a("li",[v._v("时间复杂度的系数、常数 、低阶")]),v._v(" "),a("li",[v._v("比较次数和交换（或移动）次数")])]),v._v(" "),a("h4",{attrs:{id:"排序算法的内存消耗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的内存消耗"}},[v._v("#")]),v._v(" 排序算法的内存消耗")]),v._v(" "),a("ol",[a("li",[v._v("原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。")])]),v._v(" "),a("h4",{attrs:{id:"排序算法的稳定性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的稳定性"}},[v._v("#")]),v._v(" 排序算法的稳定性")]),v._v(" "),a("ol",[a("li",[v._v("如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。")])]),v._v(" "),a("h3",{attrs:{id:"冒泡排序-bubble-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序-bubble-sort"}},[v._v("#")]),v._v(" 冒泡排序（Bubble Sort）")]),v._v(" "),a("ol",[a("li",[v._v("冒泡排序是原地排序算法吗？需要常量级的临时空间，所以是原地排序算法。")]),v._v(" "),a("li",[v._v("冒泡排序是稳定的排序算法吗？相邻的两个元素大小相等的时候，我们不做交换，是。")]),v._v(" "),a("li",[v._v("时间复杂度\n"),a("ol",[a("li",[v._v("最好情况：O(n)")]),v._v(" "),a("li",[v._v("最坏情况：O(n^2)")]),v._v(" "),a("li",[v._v("平均情况：O(n^2)")])])]),v._v(" "),a("li",[v._v("有序度是数组中具有有序关系的元素对的个数")]),v._v(" "),a("li",[v._v("逆序度 = 满有序度 - 有序度")])]),v._v(" "),a("h3",{attrs:{id:"插入排序-insertion-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入排序-insertion-sort"}},[v._v("#")]),v._v(" 插入排序（Insertion Sort）")]),v._v(" "),a("ol",[a("li",[v._v("核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序")]),v._v(" "),a("li",[v._v("不需要额外的存储空间, 是一个原地排序算法")]),v._v(" "),a("li",[v._v("稳定的排序算法")]),v._v(" "),a("li",[v._v("时间复杂度\n"),a("ol",[a("li",[v._v("最好是时间复杂度为 O(n)")]),v._v(" "),a("li",[v._v("最坏时间复杂度为 O(n^2)")]),v._v(" "),a("li",[v._v("平均时间复杂度为 O(n^2)")])])])]),v._v(" "),a("h3",{attrs:{id:"选择排序-selection-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选择排序-selection-sort"}},[v._v("#")]),v._v(" 选择排序（Selection Sort）")])])}),[],!1,null,null,null);_.default=s.exports}}]);