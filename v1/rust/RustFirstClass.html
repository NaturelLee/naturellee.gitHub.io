<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>The First Rust Class | NaturelLee Blogs</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.png">
    <meta name="description" content="Cease to upgrade, you cease to live!">
    
    <link rel="preload" href="/assets/css/0.styles.e422860a.css" as="style"><link rel="preload" href="/assets/js/app.7c37d57b.js" as="script"><link rel="preload" href="/assets/js/2.62d91e13.js" as="script"><link rel="preload" href="/assets/js/3.027ab360.js" as="script"><link rel="prefetch" href="/assets/js/10.439227e3.js"><link rel="prefetch" href="/assets/js/11.7cbbc9ad.js"><link rel="prefetch" href="/assets/js/12.184ffd58.js"><link rel="prefetch" href="/assets/js/13.149ff76c.js"><link rel="prefetch" href="/assets/js/14.1b6e964d.js"><link rel="prefetch" href="/assets/js/15.4b3916da.js"><link rel="prefetch" href="/assets/js/16.5dd0b4cc.js"><link rel="prefetch" href="/assets/js/17.ca2d0fb5.js"><link rel="prefetch" href="/assets/js/18.74cd6d44.js"><link rel="prefetch" href="/assets/js/19.cd243328.js"><link rel="prefetch" href="/assets/js/20.9efdb7b4.js"><link rel="prefetch" href="/assets/js/21.0cc9c81c.js"><link rel="prefetch" href="/assets/js/22.50d137c2.js"><link rel="prefetch" href="/assets/js/23.2ba72e90.js"><link rel="prefetch" href="/assets/js/24.c638e324.js"><link rel="prefetch" href="/assets/js/25.d52be13f.js"><link rel="prefetch" href="/assets/js/26.635e0b30.js"><link rel="prefetch" href="/assets/js/27.f5296968.js"><link rel="prefetch" href="/assets/js/28.cb2ded15.js"><link rel="prefetch" href="/assets/js/29.ababf478.js"><link rel="prefetch" href="/assets/js/4.d8c7114c.js"><link rel="prefetch" href="/assets/js/5.8cc31ec1.js"><link rel="prefetch" href="/assets/js/6.6dc7d4fb.js"><link rel="prefetch" href="/assets/js/7.0b8bdde4.js"><link rel="prefetch" href="/assets/js/8.be68c7b7.js"><link rel="prefetch" href="/assets/js/9.5b770a29.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e422860a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/favicon.png" alt="NaturelLee Blogs" class="logo"> <span class="site-name can-hide">NaturelLee Blogs</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FE" class="dropdown-title"><span class="title">FE</span> <span class="arrow down"></span></button> <button type="button" aria-label="FE" class="mobile-dropdown-title"><span class="title">FE</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/fe/hooks.html" class="nav-link">
  hooks
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/reactRefs.html" class="nav-link">
  ReactRefs
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/feInterview.html" class="nav-link">
  前端面试题
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/webFrontEndTutorial.html" class="nav-link">
  前端教程
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/reactImp.html" class="nav-link">
  React性能优化
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/EverythingYouNeedtoKnowAboutDateinJavaScript.html" class="nav-link">
  JS中的日期
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/postcss.html" class="nav-link">
  Postcss实践
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/puppeteer.html" class="nav-link">
  Puppeteer集成测试
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/sass.html" class="nav-link">
  sass
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Server" class="dropdown-title"><span class="title">Server</span> <span class="arrow down"></span></button> <button type="button" aria-label="Server" class="mobile-dropdown-title"><span class="title">Server</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/server/Restful.html" class="nav-link">
  Restful
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="OS" class="dropdown-title"><span class="title">OS</span> <span class="arrow down"></span></button> <button type="button" aria-label="OS" class="mobile-dropdown-title"><span class="title">OS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/os/os.html" class="nav-link">
  OS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Rust" class="dropdown-title"><span class="title">Rust</span> <span class="arrow down"></span></button> <button type="button" aria-label="Rust" class="mobile-dropdown-title"><span class="title">Rust</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/rust/RustBook.html" class="nav-link">
  The Book
</a></li><li class="dropdown-item"><!----> <a href="/v1/rust/RustStd.html" class="nav-link">
  Std
</a></li><li class="dropdown-item"><!----> <a href="/v1/rust/RustFirstClass.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Rust First Class
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Read" class="dropdown-title"><span class="title">Read</span> <span class="arrow down"></span></button> <button type="button" aria-label="Read" class="mobile-dropdown-title"><span class="title">Read</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/read/principles.html" class="nav-link">
  原则
</a></li><li class="dropdown-item"><!----> <a href="/v1/read/takeTimeAsFriends.html" class="nav-link">
  把时间当做朋友
</a></li><li class="dropdown-item"><!----> <a href="/v1/read/6monthEnglish.html" class="nav-link">
  半年掌握一门外语
</a></li><li class="dropdown-item"><!----> <a href="/v1/read/10StepstoBecomeaMillionairein5Years.html" class="nav-link">
  如何成为百万富翁
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Sparkling" class="dropdown-title"><span class="title">Sparkling</span> <span class="arrow down"></span></button> <button type="button" aria-label="Sparkling" class="mobile-dropdown-title"><span class="title">Sparkling</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/theRightWayToBuildYourBlog.html" class="nav-link">
  这才是搭建个人博客的正确姿
</a></li><li class="dropdown-item"><!----> <a href="/v1/hackYourMemory.html" class="nav-link">
  记忆宫殿
</a></li><li class="dropdown-item"><!----> <a href="/v1/editorSkills.html" class="nav-link">
  编辑器小技巧
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/NaturelLee/blogs/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Contact
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FE" class="dropdown-title"><span class="title">FE</span> <span class="arrow down"></span></button> <button type="button" aria-label="FE" class="mobile-dropdown-title"><span class="title">FE</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/fe/hooks.html" class="nav-link">
  hooks
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/reactRefs.html" class="nav-link">
  ReactRefs
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/feInterview.html" class="nav-link">
  前端面试题
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/webFrontEndTutorial.html" class="nav-link">
  前端教程
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/reactImp.html" class="nav-link">
  React性能优化
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/EverythingYouNeedtoKnowAboutDateinJavaScript.html" class="nav-link">
  JS中的日期
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/postcss.html" class="nav-link">
  Postcss实践
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/puppeteer.html" class="nav-link">
  Puppeteer集成测试
</a></li><li class="dropdown-item"><!----> <a href="/v1/fe/sass.html" class="nav-link">
  sass
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Server" class="dropdown-title"><span class="title">Server</span> <span class="arrow down"></span></button> <button type="button" aria-label="Server" class="mobile-dropdown-title"><span class="title">Server</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/server/Restful.html" class="nav-link">
  Restful
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="OS" class="dropdown-title"><span class="title">OS</span> <span class="arrow down"></span></button> <button type="button" aria-label="OS" class="mobile-dropdown-title"><span class="title">OS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/os/os.html" class="nav-link">
  OS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Rust" class="dropdown-title"><span class="title">Rust</span> <span class="arrow down"></span></button> <button type="button" aria-label="Rust" class="mobile-dropdown-title"><span class="title">Rust</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/rust/RustBook.html" class="nav-link">
  The Book
</a></li><li class="dropdown-item"><!----> <a href="/v1/rust/RustStd.html" class="nav-link">
  Std
</a></li><li class="dropdown-item"><!----> <a href="/v1/rust/RustFirstClass.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Rust First Class
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Read" class="dropdown-title"><span class="title">Read</span> <span class="arrow down"></span></button> <button type="button" aria-label="Read" class="mobile-dropdown-title"><span class="title">Read</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/read/principles.html" class="nav-link">
  原则
</a></li><li class="dropdown-item"><!----> <a href="/v1/read/takeTimeAsFriends.html" class="nav-link">
  把时间当做朋友
</a></li><li class="dropdown-item"><!----> <a href="/v1/read/6monthEnglish.html" class="nav-link">
  半年掌握一门外语
</a></li><li class="dropdown-item"><!----> <a href="/v1/read/10StepstoBecomeaMillionairein5Years.html" class="nav-link">
  如何成为百万富翁
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Sparkling" class="dropdown-title"><span class="title">Sparkling</span> <span class="arrow down"></span></button> <button type="button" aria-label="Sparkling" class="mobile-dropdown-title"><span class="title">Sparkling</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/v1/theRightWayToBuildYourBlog.html" class="nav-link">
  这才是搭建个人博客的正确姿
</a></li><li class="dropdown-item"><!----> <a href="/v1/hackYourMemory.html" class="nav-link">
  记忆宫殿
</a></li><li class="dropdown-item"><!----> <a href="/v1/editorSkills.html" class="nav-link">
  编辑器小技巧
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/NaturelLee/blogs/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Contact
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>The First Rust Class</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/v1/rust/RustFirstClass.html#开篇词" class="sidebar-link">开篇词</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#学习-rust-的难点" class="sidebar-link">学习 Rust 的难点</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#如何学好-rust" class="sidebar-link">如何学好 Rust?</a></li></ul></li><li><a href="/v1/rust/RustFirstClass.html#前置篇" class="sidebar-link">前置篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#内存" class="sidebar-link">内存</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#数据" class="sidebar-link">数据</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#代码" class="sidebar-link">代码</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#运行方式" class="sidebar-link">运行方式</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#编程范式" class="sidebar-link">编程范式</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#缺陷" class="sidebar-link">缺陷</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#学习资料" class="sidebar-link">学习资料</a></li></ul></li><li><a href="/v1/rust/RustFirstClass.html#基础篇" class="sidebar-link">基础篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#基本语法和基础数据类型" class="sidebar-link">基本语法和基础数据类型</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#类型系统" class="sidebar-link">类型系统</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#数据结构" class="sidebar-link">数据结构</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#错误处理的主流方法" class="sidebar-link">错误处理的主流方法</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#闭包" class="sidebar-link">闭包</a></li></ul></li><li><a href="/v1/rust/RustFirstClass.html#进阶篇" class="sidebar-link">进阶篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#类型系统-2" class="sidebar-link">类型系统</a></li></ul></li><li><a href="/v1/rust/RustFirstClass.html#并发篇" class="sidebar-link">并发篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#atomic" class="sidebar-link">Atomic</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#mutex" class="sidebar-link">Mutex</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#rwlock" class="sidebar-link">RwLock</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#semaphore" class="sidebar-link">Semaphore</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#condvar" class="sidebar-link">Condvar</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#channel" class="sidebar-link">Channel</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#actor" class="sidebar-link">Actor</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#future" class="sidebar-link">Future</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#generator" class="sidebar-link">Generator</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#async-await" class="sidebar-link">async/await</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#stream-trait" class="sidebar-link">Stream trait</a></li></ul></li><li><a href="/v1/rust/RustFirstClass.html#实战篇" class="sidebar-link">实战篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#生产环境" class="sidebar-link">生产环境</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#数据处理" class="sidebar-link">数据处理</a></li><li class="sidebar-sub-header"><a href="/v1/rust/RustFirstClass.html#软件架构" class="sidebar-link">软件架构</a></li></ul></li><li><a href="/v1/rust/RustFirstClass.html#高级篇" class="sidebar-link">高级篇</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/v1/rust/RustFirstClass.html#宏" class="sidebar-link">宏</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="the-first-rust-class"><a href="#the-first-rust-class" class="header-anchor">#</a> The First Rust Class</h1> <h2 id="开篇词"><a href="#开篇词" class="header-anchor">#</a> 开篇词</h2> <p><img src="/assets/img/rust_learning_routes.7685a0e2.png" alt="rust_learning_routes"></p> <h3 id="学习-rust-的难点"><a href="#学习-rust-的难点" class="header-anchor">#</a> 学习 Rust 的难点</h3> <ol><li>Rust 中最大的思维转换就是变量的<strong>所有权和生命周期</strong></li></ol> <h3 id="如何学好-rust"><a href="#如何学好-rust" class="header-anchor">#</a> 如何学好 Rust?</h3> <p><img src="/assets/img/firstPrinciple.73ff287f.png" alt="firstPrinciple"></p> <h4 id="_1-精准学习"><a href="#_1-精准学习" class="header-anchor">#</a> 1. 精准学习</h4> <ol><li>深挖一个个高大上的表层知识点，回归底层基础知识的本原，再使用类比、联想等方法，打通涉及的基础知识；然后从底层设计往表层实现，一层层构建知识体系</li> <li>第一性原理：回归事物最基础的条件，将其拆分成基本要素解构分析，来探索要解决的问题。</li></ol> <h4 id="_2-刻意练习"><a href="#_2-刻意练习" class="header-anchor">#</a> 2. 刻意练习</h4> <p>用精巧设计的例子，通过练习进一步巩固学到的知识，并且在这个过程中尝试发现学习过程中的不自知问题，让自己从“我不知道我不知道”走向“我知道我不知道”，最终能够在下一个循环中弥补知识的漏洞。</p> <h2 id="前置篇"><a href="#前置篇" class="header-anchor">#</a> 前置篇</h2> <h3 id="内存"><a href="#内存" class="header-anchor">#</a> 内存</h3> <p><strong>每个线程分配一个 stack，每个进程分配一个 heap。stack 是线程独占，heap 是线程共用。 stack 大小是确定的，heap 大小是动态的。</strong></p> <p>栈上存放的数据是静态的，固定大小，静态生命周期；堆上存放的数据是动态的，不固定大小，动态生命周期。</p> <h4 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h4> <ol><li>栈是自顶向下增长；</li> <li>每当一个函数被调用时，一块连续的内存（帧 frame）就会在栈顶被分配出来;</li> <li>一个新的帧会分配足够的空间存储寄存器的上下文;</li> <li>在编译时，一切无法确定大小或者大小可以改变的数据，都无法<strong>安全地</strong>放在栈上，最好放在堆上。</li> <li>栈上的内存在函数调用结束之后，所使用的帧被回收，相关变量对应的内存也都被回收待用。</li> <li>所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。</li> <li>对于存入栈上的值，它的<strong>大小在编译期就需要确定</strong>。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。</li></ol> <h4 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h4> <ol><li>堆可以存入<strong>大小未知</strong>或者<strong>动态伸缩</strong>（动态大小、动态生命周期）的数据类型。</li> <li>堆上分配出来的每一块内存需要显式地释放，这就使堆上内存有更加灵活的生命周期，可以在不同的调用栈之间共享数据。</li></ol> <h5 id="堆内存自动管理方式"><a href="#堆内存自动管理方式" class="header-anchor">#</a> 堆内存自动管理方式</h5> <ol><li>Tracing GC: tracing garbage collection; 追踪式垃圾回收</li> <li>ARC: Automatic Reference Counting; 自动引用计数</li></ol> <h3 id="数据"><a href="#数据" class="header-anchor">#</a> 数据</h3> <h4 id="值和类型"><a href="#值和类型" class="header-anchor">#</a> 值和类型</h4> <ol><li>值是无法脱离具体的类型讨论的</li></ol> <h5 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h5> <ol><li><p>原生类型</p> <ol><li>字符、整数、浮点数、布尔值、数组（array）、元组（tuple）、指针、引用、函数、闭包</li> <li>所有原生类型大小都是固定的，因此它们可以被分配到栈上。</li></ol></li> <li><p>组合类型</p> <ol><li>结构体（structure type） -- struct</li> <li>标签联合（tagged union） -- enum</li></ol></li></ol> <h4 id="指针和引用"><a href="#指针和引用" class="header-anchor">#</a> 指针和引用</h4> <ol><li>指针是一个持有内存地址的值，可以通过 derefence 来访问它指向的内存地址，理论上可以解引用到任意数据类型。</li> <li>比正常指针携带更多信息的指针称为胖指针。</li></ol> <h3 id="代码"><a href="#代码" class="header-anchor">#</a> 代码</h3> <h4 id="函数-方法-闭包"><a href="#函数-方法-闭包" class="header-anchor">#</a> 函数，方法，闭包</h4> <ol><li>函数也是对代码中重复行为的抽象。</li> <li>面向对象的编程语言中，在类或者对象中定义的函数，被称为方法（method）。方法往往和对象的指针发生关系</li> <li>闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。</li></ol> <h4 id="接口-虚表"><a href="#接口-虚表" class="header-anchor">#</a> 接口，虚表</h4> <ol><li>作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性</li> <li>在生成这个引用的时候，我们需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表。这个列表，就是我们熟知的虚表（virtual table）。</li> <li>虚表一般存储在堆上 ？？？</li> <li>虚表是每个 impl TraitA for TypeB {} 时就会编译出一份。</li> <li>比如 String 的 Debug 实现, String 的 Display 实现各有一份虚表，它们在编译时就生成并放在了二进制文件中（大多是 RODATA 段中）。</li> <li>所以虚表是每个 (Trait, Type) 一份。并且在编译时就生成好了</li></ol> <h3 id="运行方式"><a href="#运行方式" class="header-anchor">#</a> 运行方式</h3> <h4 id="同步-异步"><a href="#同步-异步" class="header-anchor">#</a> 同步，异步</h4> <h3 id="编程范式"><a href="#编程范式" class="header-anchor">#</a> 编程范式</h3> <h4 id="泛型编程"><a href="#泛型编程" class="header-anchor">#</a> 泛型编程</h4> <h3 id="缺陷"><a href="#缺陷" class="header-anchor">#</a> 缺陷</h3> <ol><li><img src="/assets/img/short.86211653.png" alt=""></li></ol> <h3 id="学习资料"><a href="#学习资料" class="header-anchor">#</a> 学习资料</h3> <ol><li><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener noreferrer">rust book<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://doc.rust-lang.org/nomicon/" target="_blank" rel="noopener noreferrer">rustnomicon rust 死灵书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://docs.rs/" target="_blank" rel="noopener noreferrer">docs.rs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://doc.rust-lang.org/stable/std/" target="_blank" rel="noopener noreferrer">标准库文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="基础篇"><a href="#基础篇" class="header-anchor">#</a> 基础篇</h2> <ol><li>Rust 是一门基于表达式（expression-based）的语言 Rust is an expression-oriented language.</li> <li>语句（Statements）是执行一些操作但不返回值的指令。表达式（Expressions）计算并产生一个值</li></ol> <h3 id="基本语法和基础数据类型"><a href="#基本语法和基础数据类型" class="header-anchor">#</a> 基本语法和基础数据类型</h3> <ol><li>变量类型一般可以省略；</li> <li>const/static 变量必须声明类型；</li> <li>函数参数的类型和返回值的类型都必须显示定义；</li> <li><strong>宏编程</strong>的主要流程就是实现若干 From 和 TryFrom</li></ol> <p><img src="/assets/img/def_datastructure.b51aa2d8.png" alt=""> <img src="/assets/img/flow_control.5c1b7967.png" alt=""></p> <h4 id="所有权和生命周期"><a href="#所有权和生命周期" class="header-anchor">#</a> 所有权和生命周期</h4> <p><strong>核心点</strong>：<strong>Rust 通过单一所有权来限制任意引用的行为</strong></p> <ol><li>Copy trait 与 Drop trait 不能共存。</li> <li>所有权转移时，优先使用 copy 语义， 默认使用 move 语义。</li></ol> <h5 id="所有权规则"><a href="#所有权规则" class="header-anchor">#</a> 所有权规则</h5> <ol><li>一个值只能被一个变量所拥有，这个变量被称为所有者</li> <li>一个值同一时刻只能有一个所有者</li> <li>当所有者离开作用域，其拥有的值被丢弃</li></ol> <h5 id="move-语义"><a href="#move-语义" class="header-anchor">#</a> Move 语义：</h5> <ol><li>赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</li></ol> <h5 id="copy-语义和-clone-语义"><a href="#copy-语义和-clone-语义" class="header-anchor">#</a> Copy 语义和 Clone 语义</h5> <ol><li>符合 Copy 语义的类型，在你赋值或者传参时，值会自动按位拷贝。</li> <li>原生类型，包括函数、不可变引用和裸指针实现了 Copy；</li> <li>数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；</li> <li>可变引用没有实现 Copy；</li> <li>非固定大小的数据结构，没有实现 Copy。</li> <li>Copy 语义<strong>仅拷贝栈上</strong>的内存。</li> <li>Clone trait 是 copy 的 super trait, <strong>深拷贝</strong>， 深拷贝得到的<strong>堆内存</strong>需用通过 Drop trait 来释放。</li> <li>任何有资源需要释放(Drop trait)的数据结构，都无法实现 Copy trait</li></ol> <h5 id="borrow-语义"><a href="#borrow-语义" class="header-anchor">#</a> Borrow 语义</h5> <ol><li>Borrow 语义通过引用语法（&amp; 或者 &amp;mut）来实现; 在 Rust 下，所有的引用都只是借用了“临时使用权”，它并不破坏值的单一所有权约束。</li> <li>默认情况下，Rust 的借用都是只读的;</li> <li><strong>Rust 所有的参数传递都是传值;</strong></li> <li>借用的生命周期及其约束: <strong>借用不能超过（outlive）值的生存期</strong>。</li> <li>在一个作用域内，仅允许一个活跃的可变引用</li> <li>在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。</li></ol> <p><img src="/assets/img/ownership_lifetime.78707782.png" alt=""></p> <h5 id="多个所有者"><a href="#多个所有者" class="header-anchor">#</a> 多个所有者</h5> <ol><li>Rust 处理很多问题的思路：编译时，处理大部分使用场景，保证安全性和效率；运行时，处理无法在编译时处理的场景，会牺牲一部分效率，提高灵活性。</li> <li>Arc(Atomic Reference Counter);</li> <li>Rc(Reference Counter)： 对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数。Rc 是一个只读的引用计数器</li> <li>Box::leak()，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。</li></ol> <p><img src="/assets/img/Box.c81c3524.png" alt="Box"></p> <h5 id="内部可变性"><a href="#内部可变性" class="header-anchor">#</a> 内部可变性</h5> <ol><li><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>针对单线程</li> <li><code>Arc&lt;Mutex&lt;T&gt;&gt;/Arc&lt;RwLock&lt;T&gt;&gt;</code>针对多线程环境</li></ol> <p><img src="/assets/img/innerMut.7acd1aa9.png" alt=""></p> <h5 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h5> <ol><li>一般来说，<strong>堆内存</strong>的生命周期，会默认<strong>和其栈内存的生命周期绑定在一起</strong>。</li> <li>生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期。</li> <li>所有引用类型的参数都有独立的生命周期 'a 、'b 等。</li> <li>如果只有一个引用型输入，它的生命周期会赋给所有输出。</li> <li>如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。</li></ol> <p><img src="/assets/img/diffLifetimes.e2ae07d6.png" alt="动态、静态生命周期"></p> <h3 id="类型系统"><a href="#类型系统" class="header-anchor">#</a> 类型系统</h3> <ol><li>类型系统是一种对类型进行定义、检查和处理的<strong>工具</strong>；</li> <li>类型，是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息；</li> <li>Rust 下的<strong>内存安全</strong>更严格：代码只能按照被允许的方法和被允许的权限，访问它被授权访问的内存；</li> <li>Rust 中除了 let / fn / static / const 这些定义性语句外，<strong>都是表达式</strong>，而一切表达式都有<strong>类型</strong>；</li> <li>unit 是只有一个值的类型，它的值和类型都是 ()；</li> <li>即使上下文中含有类型的信息，也需要开发者为变量提供类型，比如<strong>常量和静态变量</strong>的定义；需要明确的类型声明。</li></ol> <p>原生类型：
<img src="/assets/img/primitives.742d0e28.png" alt="">
组合类型：
<img src="/assets/img/composites.626227ac.png" alt="">
Rust 类型系统：
<img src="/assets/img/rustTypeSystem.a69dbc6e.png" alt=""></p> <h4 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h4> <ol><li>参数多态：代码操作的类型是一个满足某些约束的参数，而非具体的类型；=&gt; 泛型 Rust Generic</li> <li>特设多态： 一般指函数的重载；包括运算符重载 =&gt; Rust Trait</li> <li>子类型多态：在运行时，子类型可以被当成父类型使用。=&gt; Rust Trait Object</li></ol> <h4 id="泛型数据结构"><a href="#泛型数据结构" class="header-anchor">#</a> 泛型数据结构</h4> <ol><li>函数，是把重复代码中的参数抽取出来；</li> <li>泛型，是把重复数据结构中的参数抽取出来；</li></ol> <p>生命周期标注也是泛型的一部分</p> <h4 id="单态化"><a href="#单态化" class="header-anchor">#</a> 单态化</h4> <ol><li>好处： 泛型函数的调用是静态分派（static dispatch）;</li> <li>缺点 1： 编译速度慢；一个泛型函数，编译器需要找到所有用到的不同类型，一个个编译；</li> <li>缺点 2： 编译出的二进制代码会比较大，存在 N 份。</li> <li>缺点 3： 代码以二进制分发会损失泛型的信息。单态化之后，原本的泛型信息就被丢弃了。</li></ol> <h4 id="trait"><a href="#trait" class="header-anchor">#</a> trait</h4> <ol><li>定义了类型使用这个接口的行为;</li> <li>在 trait 中，方法可以有缺省的实现;</li> <li>允许用户把错误类型延迟到 trait 实现时才决定，这种带有关联类型的 trait 比普通 trait，更加灵活，抽象度更高</li> <li>trait 的”继承“： trait B 在定义时可以使用 trait A 中的关联类型和方法</li></ol> <h4 id="trait-object"><a href="#trait-object" class="header-anchor">#</a> Trait Object</h4> <ol><li><p>表现为&amp;dyn Trait 或者 <code>Box&lt;dyn Trait&gt;</code>：(动态分派（dynamic dispatch）)；</p></li> <li><p>底层逻辑就是胖指针：数据本身+虚函数表 vtable；</p></li> <li><p>如果 trait 所有的方法，返回值是 Self(trait object 产生时原来的类型会被抹去) 或者携带泛型参数(trait object 是运行时的产物)，那么这个 trait 就不能产生 trait object。</p></li> <li><p>rust会为实现了trait object类型的trait实现，生成相应的vtable，放在可执行文件中（一般在TEXT或RODATA段）。</p> <p><img src="/assets/img/rust_trait.3efedbd0.png" alt=""></p></li></ol> <h4 id="traits"><a href="#traits" class="header-anchor">#</a> Traits</h4> <p><img src="/assets/img/rust_traits.417e85dd.png" alt=""></p> <ol><li><p>send/sync: 如果一个类型 T: Send，那么 T 在某个线程中的独占访问是线程安全的；如果一个类型 T: Sync，那么 T 在线程间的只读共享是安全的;</p></li> <li><p>Clone 是深度拷贝，栈内存和堆内存一起拷贝;</p></li> <li><p>Copy 是按位浅拷贝，与 Drop 互斥；</p></li> <li><p>不支持 Send / Sync 的数据结构主要有：</p> <ol><li>裸指针 *const T / *mut T。它们是不安全的，所以既不是 Send 也不是 Sync。</li> <li>UnsafeCell 不支持 Sync。也就是说，任何使用了 Cell 或者 RefCell 的数据结构不支持 Sync。</li> <li>引用计数 Rc 不支持 Send 也不支持 Sync。所以 Rc 无法跨线程。</li></ol></li> <li><p>只需要实现<code>From&lt;T&gt;</code>， <code>Into&lt;T&gt;</code>会自动实现；</p></li></ol> <p><img src="/assets/img/rustOperators.8af7fe44.png" alt=""></p> <h4 id="延迟绑定"><a href="#延迟绑定" class="header-anchor">#</a> 延迟绑定</h4> <ol><li>从数据的角度看，[数据结构]是[具体数据]的延迟绑定，[泛型结构]是[具体数据结构]的延迟绑定；</li> <li>从代码的角度看，[函数]是一组实现某个功能的[表达式]的延迟绑定，[泛型函数]是[函数]的延迟绑定；</li> <li>[trait] 是[行为]的延迟绑定</li></ol> <h3 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h3> <ol><li><strong>指针</strong>是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；</li> <li><strong>引用</strong>是一个特殊的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用</li></ol> <p><img src="/assets/img/datastructures.41d92d34.png" alt=""></p> <h4 id="智能指针"><a href="#智能指针" class="header-anchor">#</a> 智能指针：</h4> <ol><li>是一个胖指针；</li> <li><strong>智能指针</strong>String 对堆上的值具有所有权，而<strong>普通胖指针&amp;str</strong>没有所有权；</li> <li>在 Rust 中，凡是<strong>需要做资源回收</strong>的数据结构，且实现了 <strong>Deref/DerefMut/Drop</strong>，都是智能指针</li></ol> <h5 id="box-t-在堆上创建内存"><a href="#box-t-在堆上创建内存" class="header-anchor">#</a> <code>Box&lt;T&gt;</code>在堆上创建内存</h5> <h5 id="cow-a-b-提供写时克隆"><a href="#cow-a-b-提供写时克隆" class="header-anchor">#</a> <code>Cow&lt;'a, B&gt;</code>提供写时克隆</h5> <h5 id="分发手段"><a href="#分发手段" class="header-anchor">#</a> 分发手段</h5> <ol><li>使用泛型参数做静态分发</li> <li>使用 trait object 做动态分发</li> <li>这种根据 enum 的不同状态来进行统一分发的方法是第三种分发手段，其效率是动态分发的数十倍。</li></ol> <h5 id="mutexguard-t-用于数据加锁"><a href="#mutexguard-t-用于数据加锁" class="header-anchor">#</a> <code>MutexGuard&lt;T&gt;</code>用于数据加锁</h5> <ol><li>通过 Drop trait 来确保，使用到的内存以外的资源在退出时进行释放</li></ol> <h4 id="切片-slice"><a href="#切片-slice" class="header-anchor">#</a> 切片 Slice</h4> <ol><li><p><code>&amp;[T]</code> 只读切片，只是一个借用</p></li> <li><p><code>&amp;mut[T]</code> 可写的切片</p></li> <li><p><code>Box&lt;[T]&gt;</code> 堆上分配的切片： 而 <code>Box&lt;[T]&gt;</code> 一旦生成就<strong>固定</strong>下来，<strong>没有 capacity</strong>，也无法增长；对数据具有所有权。</p></li> <li><p>Vec 可以通过 into_boxed_slice() 转换成 <code>Box&lt;[T]&gt;</code>，<code>Box&lt;[T]&gt;</code> 也可以通过 into_vec() 转换回 Vec；</p></li> <li><p>当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec，再转换成 <code>Box&lt;[T]&gt;</code> ;</p></li> <li><p><code>Box&lt;[T]&gt;</code>和<code>&amp;[T]</code>的区别：</p> <ol><li><code>Box&lt;[T]&gt;</code>指针指向的是堆内存数据；<code>&amp;[T]</code>指针指向的数据可以是堆、栈内存数据；</li> <li><code>Box&lt;[T]&gt;</code> 对数据具有所有权；<code>&amp;[T]</code>只是一个借用；</li></ol> <p><img src="/assets/img/rust_slice.bd6be881.png" alt=""></p></li></ol> <h4 id="哈希表"><a href="#哈希表" class="header-anchor">#</a> 哈希表</h4> <ol start="0"><li>哈希表最核心的特点就是：<strong>巨量的可能输入和有限的哈希表容量</strong>。</li> <li>Rust 哈希表算法的设计核心:
<ol><li>二次探查（quadratic probing）</li> <li>SIMD（单指令多数据） 查表（Single Instruction Multiple Data lookup）</li></ol></li> <li>解决哈希冲突机制
<ol><li>链地址法（chaining）</li> <li>开放寻址法（open addressing）</li></ol></li> <li>通过 shrink_to_fit / shrink_to 释放掉不需要的内存</li></ol> <p>哈希冲突解决机制
<img src="/assets/img/hash_conflict.ad8fa820.png" alt=""></p> <p>SIMD 查表
<img src="/assets/img/simd_lookup.4054a407.png" alt=""></p> <h3 id="错误处理的主流方法"><a href="#错误处理的主流方法" class="header-anchor">#</a> 错误处理的主流方法</h3> <ol><li>返回值</li> <li>异常处理</li> <li>类型系统
<ol><li>在 Rust 代码中，如果你只想传播错误，不想就地处理，可以用 ? 操作符</li> <li>使用 Option 和 Result 是 Rust 中处理错误的首选</li> <li>立刻暴露 Panic!, catch_unwind!</li></ol></li></ol> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p><img src="/assets/img/rustClosure.800ee7bd.png" alt=""></p> <ol><li>闭包是一种匿名类型，<strong>一旦声明，就会产生一个新的类型</strong>（调用闭包时可以直接和代码对应），但这个类型无法被其它地方使用。这个类型就像一个结构体，会包含所有捕获的变量。</li> <li>不带 move 时，闭包捕获的是对应自由变量的引用；</li> <li>带 move 时，对应自由变量的所有权会被移动到闭包结构中</li> <li>闭包的大小跟参数、局部变量都无关，<strong>只跟捕获的变量有关</strong>，闭包捕获的变量都存储在栈上。</li> <li>闭包是<strong>存储在栈上</strong>(没有堆内存分配)，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。</li> <li>闭包的调用效率和函数调用几乎一致</li></ol> <h2 id="进阶篇"><a href="#进阶篇" class="header-anchor">#</a> 进阶篇</h2> <h3 id="类型系统-2"><a href="#类型系统-2" class="header-anchor">#</a> 类型系统</h3> <h4 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h4> <ol><li>架构师的工作不是作出决策，而是尽可能久地推迟决策，在现在不作出重大决策的情况下构建程序，以便以后有足够信息时再作出决策。</li> <li>通过使用泛型参数，BufReader 把决策交给使用者。</li> <li>泛型参数三种常见的使用场景：
<ol><li>使用泛型参数<strong>延迟</strong>数据结构的绑定；</li> <li>使用泛型参数和 PhantomData，声明数据结构中不直接使用但在实现过程中需要用到的类型；</li> <li>使用泛型参数让同一个数据结构对同一个 trait 可以拥有不同的实现。</li></ol></li> <li>PhantomData:
<ol><li>被广泛用在处理，数据结构定义过程中不需要，但是在实现过程中需要的泛型参数;</li> <li>在定义数据结构时，对于额外的、暂时不需要的泛型参数，用 PhantomData 来“拥有”它们，这样可以规避编译器的报错。</li> <li>实际长度为零，是个 ZST（Zero-Sized Type）, 类型标记。</li></ol></li></ol> <h4 id="trait-object-2"><a href="#trait-object-2" class="header-anchor">#</a> Trait Object</h4> <ol><li>使用 Trait Object 是有额外的代价的，首先这里有<strong>一次额外的堆分配</strong>，其次<strong>动态分派</strong>会带来一定的性能损失</li> <li>当在某个上下文中需要满足某个 trait 的类型，且这样的类型可能有很多，当前上下文无法确定会得到哪一个类型时，我们可以用 trait object 来统一处理行为。</li> <li>和泛型参数一样，trait object 也是一种<strong>延迟绑定</strong>，它让决策可以延迟到运行时，从而得到最大的灵活性。</li> <li>后果是执行效率的打折。在 Rust 里，函数或者方法的执行就是一次跳转指令，而 trait object 方法的执行还多一步，它涉及额外的内存访问，才能得到要跳转的位置再进行跳转，执行的效率要低一些。</li> <li>返回/线程间传递 trait object 都免不了使用 Box 或者 Arc，会带来额外的堆分配的开销。</li></ol> <h4 id="围绕trait来设计和架构系统"><a href="#围绕trait来设计和架构系统" class="header-anchor">#</a> 围绕trait来设计和架构系统</h4> <ol><li>软件开发的整个行为，基本上可以说是不断创建和迭代接口，然后在这些接口上进行实现的过程。</li> <li>用trait做桥接</li> <li>SOLID原则
<ol><li>SRP：单一职责原则，是指每个模块应该只负责单一的功能，不应该让多个功能耦合在一起，而是应该将其组合在一起。</li> <li>OCP：开闭原则，是指软件系统应该对修改关闭，而对扩展开放。</li> <li>LSP：里氏替换原则，是指如果组件可替换，那么这些可替换的组件应该遵守相同的约束，或者说接口。</li> <li>ISP：接口隔离原则，是指使用者只需要知道他们感兴趣的方法，而不该被迫了解和使用对他们来说无用的方法或者功能。</li> <li>DIP：依赖反转原则，是指某些场合下底层代码应该依赖高层代码，而非高层代码去依赖底层代码。</li></ol></li></ol> <h4 id="网络开发"><a href="#网络开发" class="header-anchor">#</a> 网络开发</h4> <p>应表会传网链 物
<img src="/assets/img/ISO_OSI_model.faac5570.png" alt="ISO/OSI七层模型及对应协议"></p> <h4 id="unsafe-rust"><a href="#unsafe-rust" class="header-anchor">#</a> Unsafe Rust</h4> <p><img src="/assets/img/unsafe_rust.fe76ab38.png" alt="unsafe rust 场景"></p> <p><strong>可以使用、也推荐使用 unsafe 的场景</strong></p> <ol><li>实现 unsafe trait:
<ol><li>主要是Send / Sync 这两个 trait；</li> <li>任何 trait，只要声明成 unsafe，它就是一个 unsafe trait；</li> <li>unsafe trait 是对 trait 的实现者的约束</li> <li>unsafe fn 是函数对调用者的约束，需要加 unsafe block</li></ol></li> <li>调用已有的 unsafe 函数：
<ol><li>需要加 unsafe block；</li> <li>定义 unsafe 函数，在其中调用 unsafe 函数；</li></ol></li> <li>对裸指针做解引用</li> <li>使用 FFI</li></ol> <p><strong>不推荐的使用 unsafe 的场景</strong></p> <ol><li>访问或者修改可变静态变量
<ol><li>任何需要 static mut 的地方，都可以用 AtomicXXX / Mutex / RwLock 来取代。</li></ol></li> <li>在宏里使用 unsafe</li> <li>使用 unsafe 提升性能
<ol><li>而有些时候，即便你能够使用 unsafe 让局部性能达到最优，但作为一个整体看的时候，这个局部的优化可能根本没有意义。</li></ol></li></ol> <p><strong>撰写 unsafe 代码</strong></p> <ol><li>一定要用注释声明代码的安全性</li></ol> <h4 id="ffi-foreign-function-interface"><a href="#ffi-foreign-function-interface" class="header-anchor">#</a> FFI（Foreign Function Interface）</h4> <p>一门语言，如果能跟 C ABI（Application Binary Interface）处理好关系，那么就几乎可以和任何语言互通。</p> <p><strong>处理 FFI 的注意事项</strong></p> <ol><li>如何处理数据结构的差异？</li> <li>谁来释放内存？</li> <li>如何进行错误处理？</li></ol> <p><img src="/assets/img/rust_ffi_call.4d82795e.png" alt="rust 调用其他语言"></p> <p>Rust shim 主要做四件事情：</p> <ol><li>提供 Rust 方法、trait 方法等公开接口的独立函数。注意 C 是不支持泛型的，所以对于泛型函数，需要提供具体的用于某个类型的 shim 函数。</li> <li>所有要暴露给 C 的独立函数，都要声明成 #[no_mangle]，不做函数名称的改写。</li> <li>数据结构需要处理成和 C 兼容的结构。</li> <li>要使用 catch_unwind 把所有可能产生 panic! 的代码包裹起来。</li></ol> <p>FFI 的其它方式</p> <ol><li>通过网络：REST API、gRPC</li> <li>protobuf 来序列化 / 反序列化要传递的数据</li></ol> <h2 id="并发篇"><a href="#并发篇" class="header-anchor">#</a> 并发篇</h2> <p><strong>并发concurrent：轮流处理，多队列一件事；并行parallel：同时执行，多队列多件事；</strong></p> <p><img src="/assets/img/concurrent_parallel.0aef14c8.png" alt="并发vs并行"></p> <p>并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理。</p> <p>在处理并发的过程中，难点并不在于如何创建多个线程来分配工作，在于如何在这些并发的任务中进行<strong>同步</strong>。</p> <p>我们来看并发状态下几种常见的工作模式：</p> <ol><li>自由竞争模式、</li> <li>map/reduce 模式、</li> <li>DAG 模式：</li></ol> <h3 id="atomic"><a href="#atomic" class="header-anchor">#</a> Atomic</h3> <p>Atomic 是一切并发同步的基础</p> <h3 id="mutex"><a href="#mutex" class="header-anchor">#</a> Mutex</h3> <p>用来解决这种读写互斥问题的基本工具</p> <h3 id="rwlock"><a href="#rwlock" class="header-anchor">#</a> RwLock</h3> <h3 id="semaphore"><a href="#semaphore" class="header-anchor">#</a> Semaphore</h3> <h3 id="condvar"><a href="#condvar" class="header-anchor">#</a> Condvar</h3> <p>典型场景是生产者 - 消费者模式</p> <p>在实践中，Condvar 往往和 Mutex 一起使用：<strong>Mutex 用于保证条件在读写时互斥，Condvar 用于控制线程的等待和唤醒</strong>。</p> <h3 id="channel"><a href="#channel" class="header-anchor">#</a> Channel</h3> <p>Channel 把锁封装在了队列写入和读取的小块区域内，然后把读者和写者完全分离</p> <p><img src="/assets/img/channels.23b4f07c.png" alt="channels"></p> <p><img src="/assets/img/channels2.eef641d6.png" alt="channels2"></p> <h3 id="actor"><a href="#actor" class="header-anchor">#</a> Actor</h3> <p>actor 是一种有栈协程。每个 actor，有自己的一个独立的、轻量级的调用栈，以及一个用来接受消息的消息队列（mailbox 或者 message queue），外界跟 actor 打交道的唯一手段就是，给它发送消息。</p> <ol><li>Atomic 在处理简单的原生类型时非常有用，如果你可以通过 AtomicXXX 结构进行同步，那么它们是最好的选择。</li> <li>当你的数据结构无法简单通过 AtomicXXX 进行同步，但你又的确需要在多个线程中共享数据，那么 Mutex / RwLock 可以是一种选择。不过，你需要考虑锁的粒度，粒度太大的 Mutex / RwLock 效率很低。</li> <li>如果你有 N 份资源可以供多个并发任务竞争使用，那么，Semaphore 是一个很好的选择。比如你要做一个 DB 连接池。</li> <li>当你需要在并发任务中通知、协作时，Condvar 提供了最基本的通知机制，而 Channel 把这个通知机制进一步广泛扩展开，于是你可以用 Condvar 进行点对点的同步，用 Channel 做一对多、多对一、多对多的同步。</li></ol> <p>如果说在做整个后端的系统架构时，我们着眼的是：有哪些服务、服务和服务之间如何通讯、数据如何流动、服务和服务间如何同步；那么在<strong>做某一个服务的架构时，着眼的是有哪些功能性的线程（异步任务）、它们之间的接口是什么样子、数据如何流动、如何同步。</strong></p> <h3 id="future"><a href="#future" class="header-anchor">#</a> Future</h3> <h4 id="reactor-pattern-反应器模式"><a href="#reactor-pattern-反应器模式" class="header-anchor">#</a> Reactor Pattern(反应器模式)</h4> <p>Reactor Pattern 包含三部分：</p> <ol><li>tasks：待处理任务</li> <li>Executor： 调度执行tasks</li> <li>Reactor: 维护事件队列</li></ol> <p><img src="/assets/img/reactor_pattern.9e560c41.png" alt="reactor pattern"></p> <p>使用 Future 的注意事项</p> <ol><li>我们要避免在异步任务中处理大量计算密集型的工作；</li> <li>在使用 Mutex 等同步原语时，要注意标准库的 MutexGuard 无法跨越 .await，所以，此时要使用对异步友好的 Mutex，如 tokio::sync::Mutex；</li> <li>如果要在线程和异步任务间同步，可以使用 channel。</li></ol> <h4 id="状态机"><a href="#状态机" class="header-anchor">#</a> 状态机</h4> <h4 id="pin"><a href="#pin" class="header-anchor">#</a> Pin</h4> <p>Pin 是为了让某个数据结构无法合法地移动，而 Unpin 则相当于声明数据结构是可以移动的，它的作用类似于 Send / Sync，通过类型约束来告诉编译器哪些行为是合法的、哪些不是。</p> <h4 id="自引用数据结构"><a href="#自引用数据结构" class="header-anchor">#</a> 自引用数据结构</h4> <h3 id="generator"><a href="#generator" class="header-anchor">#</a> Generator</h3> <ol><li>rust中的生成器被实现为状态机。计算链的内存占用是由单个步骤所需的最大占用定义的</li></ol> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h3> <h3 id="stream-trait"><a href="#stream-trait" class="header-anchor">#</a> Stream trait</h3> <h2 id="实战篇"><a href="#实战篇" class="header-anchor">#</a> 实战篇</h2> <h3 id="生产环境"><a href="#生产环境" class="header-anchor">#</a> 生产环境</h3> <p><img src="/assets/img/rust_dev.476a3f8f.png" alt=""></p> <h3 id="数据处理"><a href="#数据处理" class="header-anchor">#</a> 数据处理</h3> <h3 id="软件架构"><a href="#软件架构" class="header-anchor">#</a> 软件架构</h3> <p><img src="/assets/img/rust_arch.7c9bc454.png" alt=""></p> <p>渐进式的架构设计，从 MVP 的需求中寻找架构的核心要素，构建一个原始但完整的结构（primitive whole），然后围绕着核心要素演进</p> <p><img src="/assets/img/arch_design.e6b139fc.png" alt=""></p> <p>分层结构、流水线结构和插件结构</p> <h2 id="高级篇"><a href="#高级篇" class="header-anchor">#</a> 高级篇</h2> <h2 id="宏"><a href="#宏" class="header-anchor">#</a> 宏</h2> <p>syn/quote</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/11/2022, 7:30:05 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----><div></div></div></div>
    <script src="/assets/js/app.7c37d57b.js" defer></script><script src="/assets/js/2.62d91e13.js" defer></script><script src="/assets/js/3.027ab360.js" defer></script>
  </body>
</html>
